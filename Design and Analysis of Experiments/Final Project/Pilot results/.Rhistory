} else {
nDims <- n
dims <- sort(sample(2:150, nDims))
meanFx1 <- vector(,nDims)
meanFx2 <- vector(,nDims)
sdFx1 <- vector(,nDims)
sdFx2 <- vector(,nDims)
for (d in 1:nDims)
{
dim <- dims[d]
fn <- function(X)
{
if(!is.matrix(X)) X <- matrix(X, nrow = 1) # <- if a single vector is passed as X
Y <- apply(X, MARGIN = 1,
FUN = smoof::makeRosenbrockFunction(dimensions = dim))
return(Y)
}
## Config 1
recpars1 <- list(name = "recombination_mmax", lambda = 0.25)
mutpars1 <- list(name = "mutation_best", f = 4)
## Config 2
recpars2 <- list(name = "recombination_npoint", N = round(dim / 2))
mutpars2 <- list(name = "mutation_rand", f = 2.2)
selpars <- list(name = "selection_standard")
stopcrit <- list(names = "stop_maxeval", maxevals = 5000*dim, maxiter = 100*dim)
probpars <- list(name = "fn", xmin = rep(-5, dim), xmax = rep(10, dim))
popsize <- 5*dim
fx1 <- vector(,nRuns)
fx2 <- vector(,nRuns)
for (i in 1:nRuns)
{
# Run algorithm 1 on problem:
out <- ExpDE(mutpars = mutpars1,
recpars = recpars1,
popsize = popsize,
selpars = selpars,
stopcrit = stopcrit,
probpars = probpars,
showpars = list(show.iters = "dots", showevery = 20))
# Extract observation:
fx1[i] <- out$Fbest
# Run algorithm 2 on problem:
out <- ExpDE(mutpars = mutpars2,
recpars = recpars2,
popsize = popsize,
selpars = selpars,
stopcrit = stopcrit,
probpars = probpars,
showpars = list(show.iters = "dots", showevery = 20))
# Extract observation:
fx2[i] <- out$Fbest
}
meanFx1[d] <- mean(fx1)
meanFx2[d] <- mean(fx2)
sdFx1[d] <- sd(fx1)
sdFx2[d] <- sd(fx2)
}
data <- data.frame(dim = dims, mean.config1 = meanFx1, mean.config2 = meanFx2,
sd.config1 = sdFx1, sd.config2 = sdFx2)
write.csv(data, file = arquivo)
}
data$n1 <- rep(nRuns, nDims)
data$n2 <- rep(nRuns, nDims)
d <- data.frame(dim = rep(data$dim,2), config = c(rep(1,nDims), rep(2,nDims)), Y = c(data$mean.config1, data$mean.config2))
for (i in 1:2){
d[, i] <- as.factor(d[, i])
}
model <- aov(Y~dim+config, data = d)
summary(model)
summary.lm(model)$r.squared
model2 <- aov(log(Y)~dim+config, data = d)
summary(model2)
summary.lm(model2)$r.squared
muD <- (data$mean.config2 - data$mean.config1)/data$mean.config2
t_test <- t.test(muD, alternative = "greater", mu = 0, conf.level = 1-alpha)
alpha <- 0.05
delta <- 0.5
beta <- 0.2
n <- 2
while (qt(1 - alpha/2, n-1) > qt(beta, n - 1, delta*sqrt(n))) n <- n + 1
print(n)
# clean workspace
rm(list=ls())
# install required packages
packages_needed <- c("ExpDE","smoof")
for (package_name in packages_needed) {
if (!(package_name %in% rownames(installed.packages()))){
install.packages(package_name)
}
}
alpha <- 0.05
delta <- 0.5
beta <- 0.2
n <- 2
while (qt(1 - alpha/2, n-1) > qt(beta, n - 1, delta*sqrt(n))) n <- n + 1
print(n)
arquivo="pilot.csv"
nRuns <- 10
suppressPackageStartupMessages(library(smoof))
suppressPackageStartupMessages(library(ExpDE))
if (file.exists(arquivo)) {
data <- read.csv(file=arquivo, header = TRUE, sep=",")
dims <- data$dim
meanFx1 <- data$mean.config1
meanFx2 <- data$mean.config2
sdFx1 <- data$sd.config1
sdFx2 <- data$sd.config2
nDims <- length(dims)
} else {
nDims <- n
dims <- sort(sample(2:150, nDims))
meanFx1 <- vector(,nDims)
meanFx2 <- vector(,nDims)
sdFx1 <- vector(,nDims)
sdFx2 <- vector(,nDims)
for (d in 1:nDims)
{
dim <- dims[d]
fn <- function(X)
{
if(!is.matrix(X)) X <- matrix(X, nrow = 1) # <- if a single vector is passed as X
Y <- apply(X, MARGIN = 1,
FUN = smoof::makeRosenbrockFunction(dimensions = dim))
return(Y)
}
## Config 1
recpars1 <- list(name = "recombination_mmax", lambda = 0.25)
mutpars1 <- list(name = "mutation_best", f = 4)
## Config 2
recpars2 <- list(name = "recombination_npoint", N = round(dim / 2))
mutpars2 <- list(name = "mutation_rand", f = 2.2)
selpars <- list(name = "selection_standard")
stopcrit <- list(names = "stop_maxeval", maxevals = 5000*dim, maxiter = 100*dim)
probpars <- list(name = "fn", xmin = rep(-5, dim), xmax = rep(10, dim))
popsize <- 5*dim
fx1 <- vector(,nRuns)
fx2 <- vector(,nRuns)
for (i in 1:nRuns)
{
# Run algorithm 1 on problem:
out <- ExpDE(mutpars = mutpars1,
recpars = recpars1,
popsize = popsize,
selpars = selpars,
stopcrit = stopcrit,
probpars = probpars,
showpars = list(show.iters = "dots", showevery = 20))
# Extract observation:
fx1[i] <- out$Fbest
# Run algorithm 2 on problem:
out <- ExpDE(mutpars = mutpars2,
recpars = recpars2,
popsize = popsize,
selpars = selpars,
stopcrit = stopcrit,
probpars = probpars,
showpars = list(show.iters = "dots", showevery = 20))
# Extract observation:
fx2[i] <- out$Fbest
}
meanFx1[d] <- mean(fx1)
meanFx2[d] <- mean(fx2)
sdFx1[d] <- sd(fx1)
sdFx2[d] <- sd(fx2)
}
data <- data.frame(dim = dims, mean.config1 = meanFx1, mean.config2 = meanFx2,
sd.config1 = sdFx1, sd.config2 = sdFx2)
write.csv(data, file = arquivo)
}
data$n1 <- rep(nRuns, nDims)
data$n2 <- rep(nRuns, nDims)
arquivo="data.csv"
if (file.exists(arquivo)) {
data <- read.csv(file=arquivo, header = TRUE, sep=",")
} else {
nmax <- 40
for (i in 1:nDims)
{
dim <- data$dim[i]
fn <- function(X)
{
if(!is.matrix(X)) X <- matrix(X, nrow = 1) # <- if a single vector is passed as X
Y <- apply(X, MARGIN = 1,
FUN = smoof::makeRosenbrockFunction(dimensions = dim))
return(Y)
}
## Config 1
recpars1 <- list(name = "recombination_mmax", lambda = 0.25)
mutpars1 <- list(name = "mutation_best", f = 4)
## Config 2
recpars2 <- list(name = "recombination_npoint", N = round(dim / 2))
mutpars2 <- list(name = "mutation_rand", f = 2.2)
selpars <- list(name = "selection_standard")
stopcrit <- list(names = "stop_maxeval", maxevals = 5000*dim, maxiter = 100*dim)
probpars <- list(name = "fn", xmin = rep(-5, dim), xmax = rep(10, dim))
popsize <- 5*dim
mu1 <- data$mean.config1[i]
s1 <- data$sd.config1[i]
n1 <- data$n1[i]
mu2 <- data$mean.config2[i]
s2 <- data$sd.config2[i]
n2 <- data$n2[i]
se <- sqrt(s1^2/n1 + s2^2/n2)
seStar <- 0.05
while( se > seStar && n1+n2 < nmax)
{
ropt <- s1/s2
if (n1/n2 < ropt)
{
# Run algorithm 1 on problem:
out <- ExpDE(mutpars = mutpars1,
recpars = recpars1,
popsize = popsize,
selpars = selpars,
stopcrit = stopcrit,
probpars = probpars,
showpars = list(show.iters = "dots", showevery = 20))
# Extract observation:
xnew <- out$Fbest
munew <- (mu1*n1 + xnew)/(n1+1)
sdnew <- sqrt(((n1-1)*s1^2 + (xnew - munew)*(xnew - mu1))/n1)
mu1 <- munew
s1 <- sdnew
n1 <- n1 + 1
}
else
{
# Run algorithm 2 on problem:
out <- ExpDE(mutpars = mutpars2,
recpars = recpars2,
popsize = popsize,
selpars = selpars,
stopcrit = stopcrit,
probpars = probpars,
showpars = list(show.iters = "dots", showevery = 20))
# Extract observation:
xnew <- out$Fbest
munew <- (mu2*n2 + xnew)/(n2+1)
sdnew <- sqrt(((n2-1)*s2^2 + (xnew - munew)*(xnew - mu2))/n2)
mu2 <- munew
s2 <- sdnew
n2 <- n2 + 1
}
se <- sqrt(s1^2/n1 + s2^2/n2)
}
data$mean.config1[i] <- mu1
data$sd.config1[i] <- s1
data$n1[i] <- n1
data$mean.config2[i] <- mu2
data$sd.config2[i] <- s2
data$n2[i] <- n2
}
}
write.csv(data, file = arquivo)
d <- data.frame(dim = rep(data$dim,2), config = c(rep(1,nDims), rep(2,nDims)), Y = c(data$mean.config1, data$mean.config2))
for (i in 1:2){
d[, i] <- as.factor(d[, i])
}
model <- aov(Y~dim+config, data = d)
summary(model)
summary.lm(model)$r.squared
model2 <- aov(log(Y)~dim+config, data = d)
summary(model2)
summary.lm(model2)$r.squared
muD <- (data$mean.config2 - data$mean.config1)/data$mean.config2
t_test <- t.test(muD, alternative = "greater", mu = 0, conf.level = 1-alpha)
t_test
shapiro.test(model$residuals)
shapiro.test(model2$residuals)
par(mfrow = c(2, 2))
plot(model2, pch = 20, las = 1)
#par(mfrow = c(1, 1))
#qqPlot(model2$residuals, pch = 20, las = 1)
muD
install.packages(c("backports", "checkmate", "curl", "data.table", "digest", "dplyr", "ellipsis", "fs", "git2r", "hexbin", "htmltools", "httpuv", "knitr", "later", "markdown", "mime", "openssl", "pkgconfig", "plotly", "processx", "promises", "purrr", "R6", "Rcpp", "RcppArmadillo", "RJSONIO", "rlang", "rmarkdown", "roxygen2", "scales", "sys", "testthat", "tibble", "tidyr", "tinytex", "vctrs", "whisker", "xfun", "xml2", "zoo"))
library(installR)
library(installr)
install.packages("installr")
library(installr)
updateR()
install.packages("car")
install.packages("multcomp")
setwd("D:\Dropbox\Dropbox\Mestrado\Disciplinas\Planejamento e Análise Experimentos\Trabalhos\Projeto Final\Resultados piloto")
data <- read.csv2("piloto.csv", sep = ',')
# Aggregate data (algorithm means by instance group)
aggdata <- with(data, aggregate(x   = as.numeric(Result), by  = list(Local.Search.Type, Problem), FUN = mean))
# Rename columns
names(aggdata) <- c("Config",
"Problem",
"Y")
# Coerce categorical variables to factors
for (i in 1:2){
aggdata[, i] <- as.factor(aggdata[, i])
}
summary(aggdata)
setwd('D:\Dropbox\Dropbox\Mestrado\Disciplinas\Planejamento e Análise Experimentos\Trabalhos\Projeto Final\Resultados piloto')
getwd()
setwd('D:/Dropbox')
getwd()
setwd('D:/Dropbox/Dropbox/Mestrado/Disciplinas/Planejamento e Análise Experimentos/Trabalhos/Projeto Final/Resultados piloto')
data <- read.csv2("piloto.csv", sep = ',')
# Aggregate data (algorithm means by instance group)
aggdata <- with(data, aggregate(x   = as.numeric(Result), by  = list(Local.Search.Type, Problem), FUN = mean))
# Rename columns
names(aggdata) <- c("Config",
"Problem",
"Y")
# Coerce categorical variables to factors
for (i in 1:2){
aggdata[, i] <- as.factor(aggdata[, i])
}
summary(aggdata)
head(data)
head(aggdata)
# Aggregate data (algorithm means by instance group)
aggdata <- with(data, aggregate(x   = Result, by  = list(Local.Search.Type, Problem), FUN = mean))
# Rename columns
names(aggdata) <- c("Config",
"Problem",
"Y")
# Coerce categorical variables to factors
for (i in 1:2){
aggdata[, i] <- as.factor(aggdata[, i])
}
summary(aggdata)
# Aggregate data (algorithm means by instance group)
aggdata <- with(data, aggregate(x   = as.numeric(Result), by  = list(Local.Search.Type, Problem), FUN = mean))
# Rename columns
names(aggdata) <- c("Config",
"Problem",
"Y")
# Coerce categorical variables to factors
for (i in 1:2){
aggdata[, i] <- as.factor(aggdata[, i])
}
summary(aggdata)
data$Result[data$Problem == 'C101']
data$Result[data$Problem == 'C101' && data$Local.Search.Type == '0LS']
length(data$Result[data$Problem == 'C101' && data$Local.Search.Type == '0LS'])
mean(data$Result[data$Problem == 'C101' && data$Local.Search.Type == '0LS'])
as.numeric(data$Result[data$Problem == 'C101' && data$Local.Search.Type == '0LS'])
as.numeric(data[data$Problem == 'C101' && data$Local.Search.Type == '0LS']$Rsult)
as.numeric(data[data$Problem == 'C101' && data$Local.Search.Type == '0LS']$Result)
data[data$Problem == 'C101' && data$Local.Search.Type == '0LS']
data[data$Problem == 'C101' & data$Local.Search.Type == '0LS']
data[data$Problem == 'C101]
]
$Result
)
()
']
data[data$Problem == 'C101']
data$Problem == 'C101'
data$Result
as.numeric(data$Result)
as.double(data$Result)
sub('.',',',data$Result)
sub(',','.',data$Result)
data$result[1]
data$Result[1]
as.double(data$Result[1])
# Exploratory data analysis: plot observations by Algorithm and Instance_Group
library(ggplot2)
# png(filename = "../figs/algo_lineplot.png",
#     width = 1000, height = 400,
#     bg = "transparent")
p <- ggplot(aggdata, aes(x = Problem,
y = Y,
group = Config,
colour = Config))
p + geom_line(linetype=2) + geom_point(size=5)
# Statistical modeling
# First model
model <- aov(Y~Config+Problem,
data = aggdata)
summary(model)
summary.lm(model)$r.squared
library(ggplot2)
# png(filename = "../figs/algo_lineplot.png",
#     width = 1000, height = 400,
#     bg = "transparent")
p <- ggplot(aggdata, aes(x = Problem,
y = Y,
group = Config,
colour = Config))
p + geom_line(linetype=2) + geom_point(size=5)
install.packages("ggplot2")
# Exploratory data analysis: plot observations by Algorithm and Instance_Group
library(ggplot2)
p <- ggplot(aggdata, aes(x = Problem,
y = Y,
group = Config,
colour = Config))
p + geom_line(linetype=2) + geom_point(size=5)
# Graphical test of assumptions
par(mfrow = c(2, 2))
plot(model, pch = 20, las = 1)
qqnorm(model$residuals, pch = 1, frame = FALSE)
qqline(model$residuals, col = "steelblue", lwd = 2)
library(car)
par(mfrow = c(1, 1))
qqPlot(model2$residuals, pch = 20, las = 1)
library(car)
par(mfrow = c(1, 1))
qqPlot(model$residuals, pch = 20, las = 1)
# Blocking efficiency
mydf        <- as.data.frame(summary(model)[[1]])
MSblocks    <- mydf["Problem","Mean Sq"]
MSe         <- mydf["Residuals","Mean Sq"]
a           <- length(unique(aggdata$Config))
b           <- length(unique(aggdata$Problem))
((b - 1) * MSblocks + b * (a - 1) * MSe) / ((a * b - 1) * MSe)
library(multcomp)
duntest     <- glht(model, linfct = mcp(Algorithm = "Dunnett"))
duntestCI   <- confint(duntest)
par(mar = c(5, 8, 4, 2), las = 1)
plot(duntestCI, xlab = "Mean difference (log scale)")
duntest     <- glht(model, linfct = mcp(Algorithm = "Dunnett"))
duntest     <- glht(model, linfct = mcp(Config = "Dunnett"))
duntestCI   <- confint(duntest)
par(mar = c(5, 8, 4, 2), las = 1)
plot(duntestCI, xlab = "Mean difference")
duntest
mcp
duntest     <- glht(model, linfct = mcp(Config = "Tukey"))
duntestCI   <- confint(duntest)
par(mar = c(5, 8, 4, 2), las = 1)
plot(duntestCI, xlab = "Mean difference")
tuktest     <- glht(model, linfct = mcp(Config = "Tukey"))
tuktestCI   <- confint(tuktest)
par(mar = c(5, 8, 4, 2), las = 1)
plot(tuktestCI, xlab = "Mean difference")
tuktest
tuktestCI
plot(tuktestCI, xlab = "Mean difference", lwd=2)
par(mar = c(5, 8, 4, 2), las = 2)
plot(tuktestCI, xlab = "Mean difference")
par(mar = c(5, 8, 4, 2), las = 1, lwd = 2)
plot(tuktestCI, xlab = "Mean difference")
par(mfrow = c(1, 1))
qqPlot(model$residuals, pch = 20, las = 1, lwd =2)
par(mar = c(5, 8, 4, 2), las = 1, lwd = 3)
plot(tuktestCI, xlab = "Mean difference")
data$Result
as.data.frame.numeric(data$Result)
mean(as.data.frame.numeric(data$Result))
dados = data$Result[1,10]
data$Result[1,10]
data$Result[1:10]
dados <- data$Result[1:10]
dados
as.numeric_version(dados)
typeof(dados)
double(dados)
as.double(dados)
dados
data <- read.csv2("piloto.csv", sep = ',', encoding = "UTF-8")
head(data)
typeof(data$Result)
as.double(data$Result)
data <- read.csv2("teste.csv", sep = ',', encoding = "UTF-8")
head(teste)
head(data)
typeof(data$Result)
data <- read.csv2("teste.csv", sep = ',', encoding = "UTF-8")
head(data)
typeof(data$Result)
as.double(data$Result)
aggdata <- with(data, aggregate(x   = as.numeric(Result), by  = list(Local.Search.Type, Problem), FUN = mean))
# Rename columns
names(aggdata) <- c("Config",
"Problem",
"Y")
# Coerce categorical variables to factors
for (i in 1:2){
aggdata[, i] <- as.factor(aggdata[, i])
}
summary(aggdata)
# Exploratory data analysis: plot observations by Algorithm and Instance_Group
library(ggplot2)
p <- ggplot(aggdata, aes(x = Problem,
y = Y,
group = Config,
colour = Config))
p + geom_line(linetype=2) + geom_point(size=5)
# Statistical modeling
# First model
model <- aov(Y~Config+Problem,
data = aggdata)
summary(model)
summary.lm(model)$r.squared
# Graphical test of assumptions
library(car)
par(mfrow = c(1, 1))
qqPlot(model$residuals, pch = 20, las = 1, lwd =2)
# Blocking efficiency
mydf        <- as.data.frame(summary(model)[[1]])
MSblocks    <- mydf["Problem","Mean Sq"]
MSe         <- mydf["Residuals","Mean Sq"]
a           <- length(unique(aggdata$Config))
b           <- length(unique(aggdata$Problem))
((b - 1) * MSblocks + b * (a - 1) * MSe) / ((a * b - 1) * MSe)
library(multcomp)
tuktest     <- glht(model, linfct = mcp(Config = "Tukey"))
tuktestCI   <- confint(tuktest)
par(mar = c(5, 8, 4, 2), las = 1, lwd = 3)
plot(tuktestCI, xlab = "Mean difference")
shapiro.test(model$residuals)
par(mfrow = c(2, 2))
plot(model2, pch = 20, las = 1)
par(mfrow = c(2, 2))
plot(model, pch = 20, las = 1)
